<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Modules – Adaptive Cruise Control</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
<nav>
    <a href="index.html">Home</a>
    <a href="background.html">Background</a>
    <a href="usecases.html">Use Cases</a>
    <a href="requirements.html">Requirements</a>
    <a href="design.html">High-Level Design</a>
    <a href="modules.html">Modules</a>
    <a href="rationale.html">Design Rationale</a>
    <a href="conclusion.html">Conclusion</a>
    <a href="fulltext.html">Full Text</a>
</nav>


<div class="container">
    <h1>Adaptive Cruise Control System</h1>
    <h2>Module Overview</h2>
    <p>
        As illustrated through the high-level design, the combination of the individual modules creates a fully functioning software system for the Adaptive Cruise Control system. Each module is responsible for a distinct function, and together they form a cohesive, hybrid architecture that balances feedback control with modular separation of concerns.
    </p>

    <h2>High-Level Functional Overview</h2>

    <h3>Module 1 – Detection and Distance Control</h3>
    <p>
        The main goal of the detection and distance control module is to determine if there is a hazard that would cause the current speed of the cruise control to be unsafe. If a hazard exists, the cruise control will then be updated. In most situations, this would be a car ahead going slower than the current cruise control set speed, but it can also include hazards such as a car accident in the lane.
    </p>
    <p>
        Therefore, the detection and tracking module needs to detect hazards, determine if a response needs to be taken, and then take that response if required. Based on these specifications, we decided that a feedback control loop would be the best architecture style for this module.
    </p>
    <p>
        The system will need to take in the current cruise control settings and then use the detection information obtained through the sensors to determine if a speed adjustment needs to be made. Once this adjustment is made, there will be an output of the following distance, which the controller will then use to determine if additional updates need to be made.
    </p>

    <figure>
        <img src="images/detection-distance-control-design.jpg" alt="Detection and Distance Control Module Diagram" style="width:100%; max-width:600px; display:block; margin:40px auto;">
        <figcaption style="text-align:center; font-style:italic;">Figure – Detection and Distance Control Module Based on Feedback Control Loop</figcaption>
    </figure>

    <h3>Module 2 – Actuators</h3>
    <p>
        As shown by Shaw’s <em>Comparing Architectural Styles</em>, there are many choices for architectural style for the basic cruise control module. As a team, we decided to represent the cruise control module as Higgin’s feedback-control architecture. We specifically chose this architecture because of its use of external information (the environment) to adjust the speed.
    </p>
    <p>
        This makes the most sense for our adaptive cruise control, as most of the changes we are making compared to the basic cruise control module have to do with how we are utilizing the external environment to make more informed and safer decisions (hazard detection). Therefore, this will allow for better integration with other modules in the overall system.
    </p>

    <figure>
        <img src="images/basic-cruise-control.jpg" alt="Basic Cruise Control Module Diagram" style="width:100%; max-width:600px; display:block; margin:40px auto;">
        <figcaption style="text-align:center; font-style:italic;">Figure – Basic Cruise Control Module Based on Feedback-Control Architecture</figcaption>
    </figure>

    <h3>Module 3 – Fault Handling</h3>
    <p>
        This module is responsible for continuously monitoring the health and consistency of the Adaptive Cruise Control system’s inputs, commands, and actuators. It operates as an independent safety layer, designed to detect, classify, and respond to abnormal or unsafe conditions in real time. The fault monitor serves as the system’s “safety guardian,” ensuring that failures are detected early and that the system transitions gracefully into a safe state when necessary.
    </p>
    <p>
        For the fault handling module, we decided to represent it using an event-driven architecture, as this style is best suited for systems that must respond dynamically to irregular or asynchronous inputs. We specifically chose this architecture because it allows the module to continuously listen for and process health and consistency events coming from multiple sources, such as sensors, vehicle feedback, and control commands. This approach enables the system to react immediately to faults, degraded performance, or unsafe operating conditions by issuing alerts, initiating safeing actions, or disabling control when necessary.
    </p>
    <p>
        This makes the most sense for our adaptive cruise control system because the ability to detect and respond to faults in real time is essential for maintaining safety and reliability in automated vehicle operation. By using an event-driven design, the module can operate independently from the main control loop, ensuring that safety monitoring continues even if other processes are delayed or interrupted. Therefore, this allows for better coordination and integration with the supervisor, control, and driver interface modules while maintaining compliance with fail-silent and graceful degradation requirements. The fault handling module, based on event-driven architecture, is displayed below.
    </p>

    <figure>
        <img src="images/fault-handling-arch.png" alt="Basic Cruise Control Module Diagram" style="width:100%; max-width:600px; display:block; margin:40px auto;">
        <figcaption style="text-align:center; font-style:italic;">Fault Handling Module Based on Event-Driven Architecture</figcaption>
    </figure>

    <h3>Module 4 – Driver Interface</h3>
    <p>
        This module is responsible for managing all communication between the driver and the Adaptive Cruise Control (ACC) system. It acts as the central point through which the driver provides input to the system and receives feedback about its current operating state. The Driver Interface captures user actions such as ON, OFF, SET, CANCEL, RESUME, and GAP adjustments, and relays these commands to the Decision/Coordination Logic for interpretation. At the same time, it displays critical system information including the current mode (CRUISE, FOLLOW, HOLD, SUSPEND, or FAULT), the set speed, following distance, and any safety alerts or warnings. By ensuring that the driver remains informed and in control, this module plays an essential role in maintaining both safety and usability.
    </p>
    <p>
        For the Driver Interface module, we decided to represent it using an event-driven architecture, as this style is best suited for systems that must handle asynchronous interactions and real-time user inputs. We specifically chose this architecture because it allows the module to process discrete events, such as button presses or pedal actions, and immediately transmit them to the Decision/Coordination Logic. Simultaneously, it listens for return events from other modules, such as status updates, warnings, or mode changes, and presents this information to the driver through the display interface. This continuous two-way communication between the driver and the system ensures that changes in the driving environment, driver intent, or system status are reflected in real time.
    </p>
    <p>
        This makes the most sense for our adaptive cruise control system because the interface must provide rapid and reliable feedback to the driver to maintain trust and situational awareness. By using an event-driven design, the Driver Interface operates independently from the main control loop, ensuring that user inputs and alerts are never delayed by other processes. Therefore, this design allows for smooth coordination with the Decision/Coordination Logic, Fault Handling, and Longitudinal Control modules while maintaining compliance with human factors and usability requirements. The Driver Interface module, based on event-driven architecture, is displayed below.
    </p>
    <figure>
        <img src="images/driver-interface-arch.png" alt="Detection and Distance Control Module Diagram" style="width:100%; max-width:600px; display:block; margin:40px auto;">
        <figcaption style="text-align:center; font-style:italic;">Figure – Driver Interface Module Based on Event-Driven Architecture</figcaption>
    </figure>
</div>
</body>
</html>
